{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Team 4500","text":"<p>Check out our badge system for 23-24 school year</p> <p>Getting Started</p>"},{"location":"Getting%20Started/software-guide/","title":"Team Wide Software Guide","text":""},{"location":"Getting%20Started/software-guide/#wpilib-vs-code","title":"WPILib VS Code","text":"<ol> <li>Go to the releases page.</li> <li>Click on the latest release not marked alpha or beta.</li> <li>Scroll down to the bottom where the assests are located.</li> <li>Click on the appropriate link for your operating system (Windows on Dr. Beauchamp's computers).</li> <li>The file should begin downloading. Once it has been downloaded, click on it.</li> <li>A security warning should show up. Click on the button that says \"Open\".</li> <li>This should open a folder in File Explorer. Click on the Application WPILibInstaller.</li> <li>Windows will try to protect your PC. Click on \"More info\", and then click \"Run anyway\"</li> <li>A pop-up should appear. Click \"Start\". Select \"Everything\", and click \"Install for this User\".</li> <li>Click \"Download for this computer only (fastest)\". Press \"Next\" once the download is finished.</li> <li>Once the rest of the download is finished, press \"Finish\".</li> <li>You have now downloaded WPILib VS Code!!</li> </ol>"},{"location":"Programming%20Prophecy/","title":"The Programming Prophecy","text":"<p>This is a resource that acts as a data warehouse for our programming team.</p> <p>Click on the titles on the left to see entries out the given subjects.</p>"},{"location":"Programming%20Prophecy/Math/eulerangles/","title":"Euler's Angles","text":""},{"location":"Programming%20Prophecy/Math/eulerangles/#finding-the-overall-angle-of-an-object-using-pitch-roll-and-yaw","title":"Finding the Overall Angle of An Object using Pitch, Roll, and Yaw","text":"\\[\\cos^{-1} \\begin{pmatrix}     \\vec{n_1} \\begin{bmatrix}     \\cos \\psi &amp; -\\sin \\psi &amp; 0 \\\\     \\sin \\psi &amp; \\cos \\psi &amp; 0 \\\\     0 &amp; 0 &amp; 1     \\end{bmatrix} \\begin{bmatrix}     \\cos \\theta &amp; 0 &amp; \\sin \\theta  \\\\      0 &amp; 1 &amp; 0 \\\\     -\\sin \\theta &amp; 0 &amp; \\cos \\theta     \\end{bmatrix} \\begin{bmatrix}     1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos \\phi &amp; -\\sin \\phi \\\\     0 &amp; \\sin \\phi &amp; \\cos \\phi     \\end{bmatrix}      \\vec{n_2} \\end{pmatrix}\\] <p>where \\(\\vec{n_1}\\) is the normal vector of the ground plane, \\(\\vec{n_2}\\) is the normal vector of the rotated plane, and \\(\\phi\\), \\(\\theta\\), and \\(\\psi\\) are the roll, pitch, and yaw angles, respectively.</p> <p>This equation represents the calculation of the overall angle of rotation of an object in 3D space based on its yaw, pitch, and roll angles. Let's break down each part of the equation:</p> <ul> <li>\\(\\cos^{-1}\\) is the inverse cosine function, which is used to calculate the angle of rotation in radians.</li> <li>\\(\\vec{n_1}\\) and \\(\\vec{n_2}\\) are vectors representing the normal vectors of two planes. In this case, \\(\\vec{n_1}\\) represents the normal vector of the ground plane (i.e., the plane with z-axis as its normal), while \\(\\vec{n_2}\\) represents the normal vector of the rotated ground plane.</li> <li>The three matrices inside the parentheses represent the three rotations needed to transform \\(\\vec{n_1}\\) into \\(\\vec{n_2}\\). These rotations are yaw (\\(\\psi\\)), pitch (\\(\\theta\\)), and roll (\\(\\phi\\)), applied in that order. Each of these matrices represents a rotation around one of the axes of the 3D coordinate system.</li> </ul> <p>To understand how these matrices work together to calculate the overall rotation angle, it's helpful to consider a simplified example. Let's say we have an object in 3D space with its normal vector aligned with the z-axis (i.e., its yaw, pitch, and roll angles are all zero). If we rotate the object around the x-axis (i.e., apply a pitch angle), the normal vector will no longer be aligned with the z-axis. We can represent this new normal vector as a combination of the original z-axis and a new y-axis that is perpendicular to both the x and z axes. This new y-axis can be obtained by rotating the original y-axis (which is perpendicular to both the x and z axes) around the x-axis by the pitch angle.</p> <p>Similarly, if we then rotate the object around the y-axis (i.e., apply a roll angle), the normal vector will be further rotated away from the z-axis. We can represent this new normal vector as a combination of the original z-axis and a new x-axis that is perpendicular to both the y and z axes. This new x-axis can be obtained by rotating the original x-axis (which is perpendicular to both the y and z axes) around the y-axis by the roll angle.</p> <p>Finally, if we then rotate the object around the z-axis (i.e., apply a yaw angle), the normal vector will be rotated even further away from the z-axis. We can represent this new normal vector as a combination of the original x, y, and z axes, rotated around the z-axis by the yaw angle.</p> <p>The matrices inside the parentheses in the equation represent these three rotations, applied in reverse order. By multiplying these matrices together and then multiplying the result by \\(\\vec{n_1}\\), we get the rotated normal vector \\(\\vec{n_2}\\). The dot product of \\(\\vec{n_1}\\) and \\(\\vec{n_2}\\) is then taken and passed through the inverse cosine function to obtain the overall angle of rotation.</p> <p>Warning</p> <p>Please do not try to make sense of this. It is just a waste of time... Pretty cool though.</p> Code Form<pre><code>/**\n    * Uses bigsad Euler Angles math to get the overall angle of the robot.\n    * @param yaw the yaw angle in radians - Rotation about the Z axis\n    * @param pitch the pitch angle in radians - Rotation about the X axis\n    * @param roll the roll angle in radians - Rotation about the Y axis\n    * @return the overall angle of the robot in radians\n    */\n    public static double getOverallAngle(double yaw, double pitch, double roll) {\n\n    // Set the ground plane normal vector\n    double[] n1 = {0.0, 0.0, 1.0};\n\n    // Calculate the rotation matrices\n    double[][] Rx = {{1.0, 0.0, 0.0},\n            {0.0, Math.cos(pitch), -Math.sin(pitch)},\n            {0.0, Math.sin(pitch), Math.cos(pitch)}};\n\n    double[][] Ry = {{Math.cos(roll), 0.0, Math.sin(roll)},\n            {0.0, 1.0, 0.0},\n            {-Math.sin(roll), 0.0, Math.cos(roll)}};\n\n    double[][] Rz = {{Math.cos(yaw), -Math.sin(yaw), 0.0},\n            {Math.sin(yaw), Math.cos(yaw), 0.0},\n            {0.0, 0.0, 1.0}};\n\n    // Calculate the normal vector of the rotated plane\n    double[] n2 = new double[3];\n    for (int i = 0; i &lt; 3; i++) {\n        n2[i] = 0.0;\n        for (int j = 0; j &lt; 3; j++) {\n            n2[i] += Rz[i][j] * Ry[j][i] * Rx[j][i] * n1[j];\n        }\n    }\n\n    // Calculate the dot product of the two normal vectors\n    double dotProduct = 0.0;\n    for (int i = 0; i &lt; 3; i++) {\n        dotProduct += n1[i] * n2[i];\n    }\n\n    // Calculate the overall tilt angle in degrees\n    return Math.acos(dotProduct);\n\n}\n</code></pre>"},{"location":"Programming%20Prophecy/Math/pid/","title":"PID","text":"\\[u(t)=K_{\\text{p}}e(t)+K_{\\text{i}}\\int _{0}^{t}e(\\tau )\\,\\mathrm {d} \\tau +K_{\\text{d}}{\\frac {\\mathrm {d} e(t)}{\\mathrm {d} t}}\\] <p>PID consists of 3 terms: Kp, Ki, and Kd.</p> <p>PID depends on knowing what your position is compared to where you want to be. This is known as the error and denoted as \\(e(t)\\).</p> <p></p> \\[e(t) = target - current\\] <p>The first segment of the PID is \\(K_pe(t)\\). In this case, a constant \"Kp\" is multiplied by the error at a certain time. </p> <p>This makes it so that as the error decreases, (ie. you get closer to the target) the power output is lowered. This results in a graph that looks like the image shown</p> <p>Although this gives us the intended effect of slowing down as we get closer to the target, we don't quite get to the target. We have two options in this case: 1. Focus on refining the Kp value, and 2. Include a Ki value.</p> <p>Note</p> <p>Havings a Kp value that is too high causes oscilations. This occurs when the power output is too high to slow down in time and the program overshoots the target.</p> <p></p> <p>By adding a Ki term to the pid, we can add a term that sums a fraction of the area to the output. This means that if we have a situation like seen above, as time increases, the output would increase too. This overcomes the voltage needed to overcome static friction.</p> <p>Warning</p> <p>Having a Ki value can be disasterous if an obstruction occurs on the motor. This means that the output gets absurdly high when something is blocking the motor.</p> <p>The Kd term can help if you are going too fast to stop, but in general you should be able to get by with just the Kp term.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Classes/","title":"Classes","text":"<p>A class is a template for an object, and they are the main building blocks of a java program. Each class contains a constructor to create an object and methods to define what that object can do. They also contain attributes, or variables, which allow them to hold information about themselves.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Classes/#class-attributes","title":"Class Attributes","text":"<p>A class' attributes represent information that an object of that class would hold. These attributes can be primitives, like doubles or booleans, or they can be objects of other classes. </p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Classes/#class-methods","title":"Class Methods","text":"<p>A class' methods represent actions that an object of that class could take. These methods can carry out tasks or return information. </p> <p>Class Constructor</p> <p>A class' constructor is a special method that is called when an object is first created. It has a return type of the class it belongs to, and is used for initializing values.</p> Example Class<pre><code>public class Student {\n    // Below are some examples of class attributes\n    private double gpa;\n    private int age;\n    private String name;\n    private boolean doesSports;\n\n    // Here is a constructor\n    public Student() {\n        // Inside the constructor we set initial values\n        gpa = 3.5;\n        age = 14;\n        name = \"Bob\";\n        doesSports = false;\n    }\n\n    // Here is a class method that represents an action a student can take\n    public void birthday() {\n        age = age + 1;\n    }\n\n    // Here is a class method that returns information about the student\n    public double getGpa() {\n        return gpa;\n    }\n}\n</code></pre>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/","title":"Methods","text":"<p>A method is a block of code that does something. Every method has five parts: the scope, return type, name, parameters, and actual code.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/#scope","title":"Scope","text":"<p>The scope of the method states where in the program it can be used. There are two main scopes that we use, public and private.</p> <p>Public scope, also known as global scope, means that the method can be used anywhere in the program.</p> <p>Private scope, also known as local scope, means that the method can only be used inside the class it was created in.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/#return-type","title":"Return Type","text":"<p>Sometimes, a method should hand back data to where it was called. Return type is used to declare what type of information the method will send back. Methods can return primatives or objects, using the <code>return</code> keyword. If a method returns a data type, that method call can be used as if it was that data type.</p> <p>However, not all methods need to return data. If a method doesn't need to return data, its return type is <code>void</code>.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/#name","title":"Name","text":"<p>Every method needs a name, which is how it can be called by other parts of the program. By convention, we use camel case to name our methods, meaning every word is capitalized except for the first. For example <code>testMethod</code> would be a conventional method name. Your method name should be descriptive enough that the person using it should have a clear idea of its purpose.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/#parameters","title":"Parameters","text":"<p>Sometimes, a method needs outside information to complete its task. We can pass in this outside information as parameters. Inside the parentheses beside the method name, we can put in as many parameters as needed, seperated by commas. Each parameter needs a type and a name. For example, a method could have the parameters <code>double runtime boolean logData</code>, since each parameter has a name and type, and the parameters are seperated by commas.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Methods/#code","title":"Code","text":"<p>The final part of the method is the code that runs when the method is called. Pretty much anything can go inside a method, from creating objects to calling other methods. If the method has a return type that isn't void, it must return data of that type. Parameters can be called by their name, and if there is a conflict between a parameter name and the name of another variable, the parameter will be chosen.</p> Example Methods<pre><code>private int studentAge = 14;\n/**\n * This method has a public scope and returns a student's age as an integer.\n */\npublic int getStudentAge() {\n    return studentAge;\n}\n\n/**\n * This method has a public scope, but no return type. \n * It takes a new age as an input and sets the students age to that age. \n */\npublic void setStudentAge(int newAge) {\n    studentAge = newAge;\n}\n\n/**\n * This method also has a public scope and no return type. \n * It changes the student's age by a certain amount of years. \n * Notice how it is calling the setStudentAge function, \n * and also how the getStudentAge function is being used \n * in place of an integer \n */\npublic void changeStudentAge(int yearsAdded) {\n    setStudentAge(getStudentAge() + yearsAdded);\n}\n</code></pre>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/","title":"Primitives","text":"<p>primitives are the most basic values in java. There are 8 types of primitives: boolean, char,  int, byte, shot, long, float, and double.</p> <p>For the most part, we will only be using 3 of these primitives: int, double, and boolean. </p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/#integers","title":"Integers","text":"<p>The int keyword is used for integers, which are all positive and negative whole numbers, including zero. Some examples of integers are -1, 1, and 0.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/#doubles","title":"Doubles","text":"<p>The double keyword is used for decimals, which are all numbers, positive or negative. Some examples of decimals are 16.2, 0.01, -2.3, and 1.0. Notice how an integer (1) can also be stored as a double (1.0).</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/#booleans","title":"Booleans","text":"<p>The boolean keyword is used to represent true and false statements. Booleans only have two states, true and false. Some examples of booleans are true and false.</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/#strings-the-fake-primitive","title":"Strings: The Fake Primitive","text":"<p>The String keyword is used to represent a collection of characters, or a word. Strings are used similarly to primitives, but unlike primitives, Strings are objects with methods inside them. Some examples of Strings are \"hi\" and \"a\"</p>"},{"location":"Programming%20Prophecy/Tutorials/Java%20Basics/Primitives/#how-to-use-primitives","title":"How to Use primitives","text":"<p>The main differences between primitives and objects is how they are created. primitives don't need to be created via a constructor. Instead they can just be assigned a value. </p> <p>Examples:</p> <pre><code>int age = 5;\n</code></pre> <pre><code>boolean trustworthy = false;\n</code></pre> <pre><code>double timeSeconds = 0.5;\n</code></pre> <pre><code>String name = \"Bob\";\n</code></pre> <p>Notice how Strings can be assigned a value just like the other primitives. Althrough it is a class, you dont have to specify <code>new String()</code>.</p>"}]}